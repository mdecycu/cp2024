var tipuesearch = {"pages": [{'title': 'About', 'text': '課程倉儲:\xa0 https://github.com/mdecycu/cp2024 \n 課程網頁:\xa0 https://mde.tw/cp2024 \n 課程目標: \n 學習如何利用 Python 程式協助執行機電整合系統設計 \n 課程教材: \n 電子書:  Learn Python with Jupyter  (5.6MB) \n 教材介紹:  Introducing "Learn Python with Jupyter" \n 教材網站:  https://www.learnpythonwithjupyter.com/ \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入  https://login.microsoftonline.com/  Office 365 \n Teams 團隊代碼: fqpabi8 \n USB 隨身碟: \n 下載可攜程式套件  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 零組件繪圖套件:\xa0 Solvespace  (已包含在可攜程式套件中) \n 機電模擬套件:\xa0 CoppeliaSim  (已包含在可攜程式套件中) \n Reference: \n https://github.com/microsoft/pybryt  (auto-assessment Python library for teaching and learning) \n https://formosa.oj.cs.nycu.edu.tw/signin/ \n https://leetcode.com/ \n https://www.hackerrank.com/domains/python \n https://py.checkio.org/ \n 清大資工大一的 C++ 計算機程式課程( 兩個學期 ) \n 東吳 自動化程式評測系統 \n 課程評分: \n 出席 (10%) - 自行舉證評分 \n Github Classroom 作業與隨堂考試 (70%) - 以 Github 帳號領取作業倉儲後, 建立包含操作流程影片與檔案下載的網頁 \n 期末口頭與書面專題報告 (20%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告 \n \n 行事曆 \n  全頁檢視  \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Links', 'text': '1a site and repo \n 1b site and repo \n 上列學員的作業網站與倉儲連結資料, 取自  https://github.com/mdecycu/list  倉儲中各班名單的 Github Pages, 若學員的 Github 帳號有異動, 必須重新領取作業倉儲並透過 Pull Requests 加入或修改與本身學號對應的 Github 帳號. \n 學號與 Github 帳號間的分隔符號為 Tab, 也就是 \\t, Pull Requests 是一種允許任何 Github 使用者透過軟性且間接的方式, 提出修改任何公開倉儲中的任何資料. \n 所謂軟性, 意即針對任何公開倉儲, 雖然任何 Github 使用者, 都可以透過 Pull Requests 提議修改內容, 但是否將修改的內容合併入目標倉儲的決定權, 並不在提出 Pull Requests 的用戶, 而是掌握在對目標倉儲有直接修改權的 Github 用戶. \n 所謂間接, 指的是 Pull Requests 並非直接對目標倉儲的內容進行修改, 而是必須先登入 Github 帳號後, 連線到目標倉儲的網址, 然後透過 Fork 功能, 將目標倉儲"插"一份到自己的帳號下, 由於"插"回來的倉儲是位於自己的帳號下, 因此可以對 Forked 倉儲內容進行修改. \n 但是修改 Forked 倉儲內容之後, 必須透過建立 Pull Requests, 將此 PR 通報到目標倉儲, 然後再由目標倉儲的管理者決定是否接受此"拉回"合併的"請求". \n 上面所說明的所謂 Pull Requests 是希望從 Forked 倉儲的版本資料, 合併至目標倉儲, 其決定權在目標倉儲的管理者. 但另外一種使用情境則是, 當目標倉儲被某一使用者 Fork 之後, 目標倉儲的內容因為改版而變更後, 若先前 Forked 倉儲希望取得目標倉儲所進行的修改內容, 需要在建立所謂 Pull Requests 流程時的 URL, 將目標倉儲的管理者帳號與 Forked 倉儲用戶帳號對調, 要求執行所謂的"逆向" Pull Requests. \n 由於"逆向" Pull Requests 的合併, 是希望將目標倉儲的修改內容, 合併至 Forked 倉儲, 其決定權自然屬於 Forked 倉儲的用戶, 因此該用戶可以自行同意該"逆向" Pull Requests 的合併請求, 讓 Forked 倉儲的內容與目標倉儲保持同步. \n', 'tags': '', 'url': 'Links.html'}, {'title': 'Office365', 'text': '計算機程式上課時段將利用 MS Teams 進行線上串流, 學員登入 @nfu 網域的 Teams 後, 可以即時觀看 demo 電腦的桌面, 而關鍵操作畫面將會透過錄影存為 .mp4 後上傳至  Mdecourse . \n 首次使用 @nfu 網域設置的 MS Office 365, 請參考下列步驟登入計算機程式課程的 MS Teams: \n \n 學校 web mail:  https://mail.nfu.edu.tw \n 密碼重置系統:  https://pwd.nfu.edu.tw/ \n 登入  https://mail.nfu.edu.tw  後收信匣中, 可看到校方寄出的 "Office 365 學生帳號說明"信件, 說明如何登入 Office 365 \n 登入 Office 365 後, 若在電腦教室可以選擇使用網頁版 \n 線上課程將使用 Office 365 的 Teams, 計算機程式課程的 Teams 團隊代碼:  ldodwua \n \n 申請 Github 帳號步驟: \n \n 連結至  https://github.com/join \n 填寫基本資訊: \xa0\xa0 - Username：輸入希望採用的用戶名稱, 若無法使用自己的學號, 可以在學號前加入英文姓名三個簡寫字母 \xa0\xa0 - Email address：輸入電子郵件地址, 可以使用上列學校配發的電子郵件地址 \xa0\xa0 - Password：設定密碼 \n 完成驗證: GitHub 會要求完成驗證以確認不是機器人, 通常需要選擇或標記圖片來完成這個步驟 \n 選擇 Free 方案後可以選擇是否願意訂閱電子報 \n 點擊 Create account 按鈕以完成註冊 \n 帳號建立後, GitHub 會發送一封驗證郵件, 必須點擊其中的驗證連結才能開始使用 Github 建立倉儲與 Gist \n 驗證郵件後, 可以登入 GitHub 進行基本設置, 例如:個人資料、SSH 金鑰配置等 \n \n Github 帳號的 Two-factor authentication (兩段式認證): \n 透過  https://chatgpt.com/  詢問: \n "Github 帳號的 Two-factor authentication 如何設定?" \n', 'tags': '', 'url': 'Office365.html'}, {'title': 'Evaluate', 'text': '網頁內容評分: 用來評量受評者的作業網頁內容, 是否完整且充實 \n 操作影片評分: 用來評量受評者所提供的操作影片內容, 是否說明清楚, 提供字幕且完整呈現標的內容 \n 倉儲提交說明: 用來評量受評者所提供的倉儲提交說明是否清楚, 以及提交次數及頻率, 是否足以證明其用功程度 \n 下載檔案評分: 用來評量受評者在作業網頁上所提供的檔案下載內容, 是否完整且內容充實 \n 作業心得評分: 用來評量受評者的作業心得是否內容豐富, 且值得令人讚賞與學習 \n \n 以上各分項評分各佔 20%, 評分基準如下: \n 非常棒 - 得 20 分 (即一百分, 表現非常棒且完美的評分) \n 很棒 - 得 18 分 (即九十分, 表現很棒的的評分) \n 很好 - 得 16 分 (即八十分, 表現很好的評分) \n 還可以 - 得 14 分 (即七十分, 表現還可以的評分) \n 及格 - 得 12 分 (即六十分, 表現算是及格的評分) \n 需加強 - 得 10 分 (即五十分, 需要再加強的評分) \n', 'tags': '', 'url': 'Evaluate.html'}, {'title': 'Jupyter', 'text': "USB 隨身碟: \n 下載可攜程式套件  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 利用 Jupyter 建立 .ipynb 格式的 notebook 檔案: \n \n 以 start_ipv6.bat 開啟隨身碟中的可攜程式環境 \n 在命令列視窗中, 輸入 jupyter lab --collaborative 後可在瀏覽器中開啟 Jupyter lab \n 系統內定以執行 jupyter lab --collaborative 指令所在目錄作為根目錄 \n Jupyter lab 的伺服器 ip 設定位於 home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.ip 變數, 內定為 localhost, 使用者可以自行修改為電腦連外 IPv4 或 IPv6 位址 \n home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.port = 8888 為內定連線埠號 \n 系統內定使用 http 連線, 使用者可利用 openssl 建立 cert.pem 與 key.pem, 並與 c.ServerApp.certfile 及c.ServerApp.keyfile 等系統變數綁定後, 使用 https 連線 \n 若希望讓其他用戶透過網路進行協同編輯, 可從命令列視窗中, 輸入 jupyter server list 取得登入所需的 token, 或將設定修改為使用者自訂的密碼登入 \n 各 Jupyter lab 用戶可從左方的 Collaboration 頁面中檢視參與協同者的名單 \n 使用結束後, 以 File - Shutdown 關閉 Jupyterlab \n \n 利用 openssl 指令建立 cert.pem 與 key.pem: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 使用 https 連線時, cert.pem 與 key.pem 設定: \n c.ServerApp.certfile = u'y:\\home_ipv6\\.jupyter\\cert.pem' \n c.ServerApp.keyfile = u'y:\\home_ipv6\\.jupyter\\key.pem' \n Jupyter 中使用 iframe 標註: \n from IPython.display import IFrame\nIFrame('https://mde.tw', width=700, height=350) \n 分享 .ipynb 檔案內容: \n 將 .ipynb 檔案上傳至作業網站中的 downloads 目錄後, 完成提交推送至 Github 後, 將連結附加在  https://nbviewer.org/urls/  之後. \n 將 .ipynb 檔案內容放入個人 Github 帳號下的 Gist 後, , 將連結附加在  https://nbviewer.org/urls/  之後. \n 例如: 以下提供 Gist 中的 .ipynb \n 01_string_input_print.ipynb \n", 'tags': '', 'url': 'Jupyter.html'}, {'title': 'W&H', 'text': '為什麼學習 Python, 如何應用 Python? \n 40723210_2018.7z \xa0( https://github.com/s40723210/cp2018 ) \n https://www.verytechnology.com/iot-insights/why-mechanical-engineers-should-embrace-python-programming \n Python for Mechanical Engineers  (機械工程師 (適用) 的 Python) -  Video1 ,  Video2 \n Python installation \n Basics of Python \n Data Types in Python Loops - For Loop Loops - If Loop Loops _While Loop Functions in Python \n Numpy library - Working with Arrays and Matrices \n Ploting with Matplotlib \n Programs on Mechanics and Machine Design \n Programs on Mechanical Vibration \n Programs on Thermal System \n Engineering Math \n Advanced Engineering Programs \n Python for Everyone  (所有人 (適用) 的 Python) \n Why we program? \n Installing Python \n Variables and Expressions \n Conditional Code \n Functions \n Loops and Iteration \n Why and How? \n 設計運算: \n https://www.studysmarter.co.uk/explanations/engineering/design-engineering/design-calculation/  (一般工程運算) \n fem_and_runge-kutta.7z \n meArm_robot_ik_sympy.7z \n stl_splliter.7z  (S TL 格式 組立件拆解) \n https://github.com/KmolYuan/Pyslvs-UI  (平面機構合成) \n 控制與模擬: \n https://docs.wokwi.com/  (機電控制系統模擬) \n https://mde.tw/cad2024/content/CoppeliaSim.html  (機電系統模擬) \n https://github.com/mdecycu/PyWeb3D  (3D 造型模擬) \n https://thebookofshaders.com/?lan=ch  (著色運算) \n 內容管理: \n https://github.com/mdecycu/cmsimde  (內容管理系統) \n https://www.odoo.com  (企業管理系統) \n https://github.com/mdecycu/pj5073  (內容管理系統) \n CAD 套件應用延伸: \n https://mde.tw/cad2024/content/NXOpen.html  (利用程式建立零組件) \n https://github.com/mdecycu/nxopen \n', 'tags': '', 'url': 'W&H.html'}, {'title': 'DC', 'text': 'Design Calculation \n 設計運算: \n https://www.studysmarter.co.uk/explanations/engineering/design-engineering/design-calculation/  (一般工程運算) \n fem_and_runge-kutta.7z  (有限元素分析與 Runge-Kutta 數值分析) \n meArm_robot_ik_sympy.7z  (符號式逆向運動分析) \n stl_splliter.7z  (S TL 格式 組立件拆解) \n https://github.com/KmolYuan/Pyslvs-UI  (平面機構合成) \n', 'tags': '', 'url': 'DC.html'}, {'title': 'AI', 'text': 'From  ChatGPT : \n 請條列出您對於初學計算機程式課程的機械設計工程系大一學生的建議 : \n 1. 選擇適合的編程語言 \xa0\xa0\xa0 Python：簡單易學，語法直觀，適合初學者。 \xa0\xa0\xa0 C/C++：常見於工程應用，有助於理解底層運作原理。 2. 打好基礎概念 \xa0\xa0\xa0 變數和數據類型：了解不同類型數據的存儲和操作方式。 \xa0\xa0\xa0 控制結構：如條件語句(if-else)和循環(for, while)。 \xa0\xa0\xa0 函數：學會如何定義和調用函數，提高代碼重用性。 3. 理解數據結構和算法 \xa0\xa0\xa0 基本數據結構：如陣列、鏈結串列、堆疊、佇列等。 \xa0\xa0\xa0 常見算法：如排序、搜索算法，這些都是解決複雜問題的基礎。 4. 多做練習 \xa0\xa0\xa0 編程題目：如LeetCode、HackerRank等網站上的練習題。 \xa0\xa0\xa0 實際項目：嘗試參與簡單的項目或課程作業，應用所學知識。 5. 理解機械設計與編程的結合 \xa0\xa0\xa0 CAD軟體插件：學習如何用編程來擴展CAD軟體功能。 \xa0\xa0\xa0 模擬和分析工具：如MATLAB，用於數據分析和模擬。 6. 保持好奇心和耐心 \xa0\xa0\xa0 持續學習：編程是一門不斷發展的技術，保持對新技術的好奇心。 \xa0\xa0\xa0 解決問題：學會從錯誤中學習，每次Debug都是一次成長的機會。 7. 參與學習社群 \xa0\xa0\xa0 線上論壇：如Stack Overflow，獲取幫助和資源。 \xa0\xa0\xa0 學校社團：參與校內相關的編程或工程設計社團，增加實踐機會。 8. 管理好學習時間 \xa0\xa0\xa0 制定計劃：安排好學習進度，每天或每週都有固定的編程時間。 \xa0\xa0\xa0 勞逸結合：合理安排休息時間，保持身心健康。 9. 掌握基礎工具 \xa0\xa0\xa0 編輯器和IDE：如VS Code, PyCharm等，選擇一個適合自己的開發環境。 \xa0\xa0\xa0 版本控制：學習使用Git，便於代碼管理和協作。 10. 不斷提升 \xa0\xa0\xa0 參加競賽：如編程競賽或機械設計比賽，提升自己的實力。 \xa0\xa0\xa0 實習經驗：嘗試找實習或參與實際項目，積累工作經驗。 \n 接下來請一律使用中文繁體用語回答, 請就"Python：簡單易學，語法直觀，適合初學者。" 仔細說明緣由,\xa0 Python 對機械設計領域有何用處, 並且舉出實例, 而且列出範例原始碼說明 . \n Python：簡單易學，語法直觀，適合初學者的緣由: \n 緣由說明 \n 語法簡單明瞭：Python的語法設計注重可讀性，使用縮排來表示程式塊，而非繁瑣的括號或關鍵字，使代碼結構清晰易懂。 \n 動態類型語言：變數在使用前無需宣告類型，簡化了代碼撰寫和維護過程。 \n 豐富的標準庫：Python擁有大量的標準庫和第三方庫，涵蓋了網路、檔案處理、數據分析、機器學習等多方面功能，初學者可以方便地使用這些庫來完成複雜的任務。 \n 龐大的社群支持：Python社群活躍，有大量的學習資源、教程和範例代碼，初學者遇到問題時可以輕鬆找到幫助。 Python對機械設計領域的用處 \n 用途說明 \n 自動化任務：Python可以用來自動化重複性工作，如文件處理、數據轉換、報告生成等，節省時間和提高效率 \n 數據分析與可視化：利用 Python 的數據分析和可視化庫（如 Pandas、Matplotlib、Seaborn），可以輕鬆地進行數據處理、分析和圖表繪製，輔助設計決策。 \n CAD軟體插件開發：Python可用於開發 CAD 軟體（如 AutoCAD、SolidWorks）的插件，擴展其功能，實現定制化的設計需求。 \n 數值計算與模擬：使用 NumPy、SciPy 等科學計算庫，可以進行複雜的數值計算和模擬，解決工程中的數學問題。 實例與範例原始碼 \n 實例一：數據分析與可視化 \n 假設我們有一組機械零件的測量數據，需分析其尺寸分佈情況。 \n import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# 創建假設的數據集\ndata = {\n    \'零件編號\': [\'A\', \'B\', \'C\', \'D\', \'E\'],\n    \'長度(mm)\': [50.5, 49.8, 50.1, 50.0, 49.9],\n    \'寬度(mm)\': [20.2, 20.0, 20.3, 20.1, 20.2]\n}\ndf = pd.DataFrame(data)\n\n# 數據分析\nmean_length = df[\'長度(mm)\'].mean()\nmean_width = df[\'寬度(mm)\'].mean()\n\nprint(f\'平均長度: {mean_length} mm\')\nprint(f\'平均寬度: {mean_width} mm\')\n\n# 數據可視化\nplt.figure(figsize=(10, 5))\nsns.barplot(x=\'零件編號\', y=\'長度(mm)\', data=df)\nplt.title(\'零件長度分佈\')\nplt.show()\n \n 這段代碼創建了一個假設的機械零件測量數據集，並計算其平均長度和寬度，最後使用 Seaborn 程式庫生成長度分佈圖。 \n 計算機械零件測量數據的平均長度和寬度，以及生成長度分佈圖，可以在機械設計和製造過程中有多種用途： \n 1. 質量控制與檢驗 在生產過程中，測量零件的尺寸並計算其平均值和分佈情況，有助於確認產品是否符合設計規範和質量標準。若有偏差，可以及時調整製造工藝，減少次品率。 \n 2. 設計改進 分析零件的實際尺寸數據，可以幫助工程師了解製造過程中的偏差，從而改進設計，提高產品的精度和可靠性。 \n 3. 統計分析 透過統計分析零件的測量數據，工程師可以識別出生產中的異常情況，如機器故障或操作問題，並採取相應措施進行修正。 \n 4. 預測與決策支持 統計數據可以作為製造過程中決策支持的依據，例如調整加工參數、預測壽命、安排維護等。 \n 5. 供應鏈管理 了解零件的尺寸分佈，可以幫助企業在供應鏈管理中進行更好的採購和庫存管理，確保供應鏈的穩定性和高效性。 \n 了解零件的尺寸分佈可以在供應鏈管理中提供多方面的幫助，進行更好的採購和庫存管理的原因如下： \n 1. 確保品質穩定 了解零件的尺寸分佈可以確保所採購的零件符合設計規格和品質標準。若尺寸分佈出現較大偏差，可以及時與供應商溝通，確保產品質量穩定，避免因不合格零件導致的生產問題。 \n 2. 減少庫存成本 精確的尺寸數據可以幫助企業更準確地預測零件的需求，避免因過度採購導致的庫存積壓，或因庫存不足而影響生產。這有助於降低庫存成本，提高資金利用效率。 \n 3. 提高生產效率 了解零件的尺寸分佈可以及早發現可能的質量問題，從而及時調整生產計劃，避免因不合格零件進入生產線而引發的停工或返工問題，提升生產效率。 \n 4. 優化供應鏈合作 透過分析零件尺寸分佈，企業可以與供應商合作進行質量改進，提升整體供應鏈的運營效率。透明的數據交流有助於建立更好的合作關係，達到雙贏效果。 \n 5. 制定採購策略 根據零件尺寸分佈情況，企業可以制定更精確的採購策略。例如，若某一批次的零件尺寸分佈較為穩定，企業可以考慮與該供應商加強合作，進行批量採購，從而獲得更好的價格優惠。 \n 6. 風險管理 了解零件的尺寸分佈還可以幫助企業識別供應鏈中的潛在風險，及早制定應對策略。例如，如果發現某供應商的零件尺寸波動較大，可以考慮尋找備選供應商，以減少供應風險。 \n 具體範例說明 假設一家公司需要採購大量的螺栓進行組裝，並且這些螺栓的尺寸需要非常精確才能保證產品的可靠性。公司可以通過以下步驟進行供應鏈管理： 1. 數據收集與分析 \n 公司定期收集每批次螺栓的尺寸數據，並使用 Python 進行分析和可視化，了解螺栓的尺寸分佈情況。 2. 品質控制 \n 如果某一批次的螺栓尺寸分佈偏離設計規格，公司可以立即通知供應商，要求進行改進，並且可以拒收不合格的產品，確保進入生產線的零件都符合標準。 3. 庫存管理 \n 通過分析歷史數據，公司可以預測未來的螺栓需求，合理安排採購計劃，避免庫存積壓或短缺。例如，如果某些時間段的需求量較大，公司可以提前增加庫存，平衡供需。 4. 供應商評估 \n 根據每個供應商提供螺栓的尺寸穩定性和合格率，公司可以進行供應商評估，選擇優質供應商，建立長期合作關係，同時淘汰質量不穩定的供應商。 \n', 'tags': '', 'url': 'AI.html'}, {'title': 'Servers', 'text': '在 Windows 中由管理者身分啟動的命令列, 可以利用 net user username password /add 建立登入帳號. \n # Switching to openssl\n# https://github.com/desktop/desktop/issues/3260\n[http "https://github.com"]\n    sslVerify = false \n Windows 的啟動目錄: \n C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup \n read_stud_id.ps1 \n # 讀取檔案，使用 -Delimiter 參數以 Tab 隔開\n$data = Import-Csv -Path "Y:\\tmp\\create_users\\list_2b.txt" -Delimiter "`t" -Header "Column1", "StudentID"\n\n# 提取第二個欄位（學號）並將結果存儲到新檔案\n$data.StudentID | Set-Content -Path "Y:\\tmp\\create_users\\user_id.txt"\n\nWrite-Host "學號已成功提取並儲存到 user_id.txt"\n \n gen_stud_id_password.ps1 \n # 讀取學號檔案\n$studentIds = Get-Content -Path "Y:\\tmp\\create_users\\2b_user_id.txt"\n\n# 初始化結果陣列\n$results = @()\n\n# 隨機生成密碼的函數\nfunction Generate-RandomPassword {\n    $length = 4\n    # 排除容易混淆的字符\n    $characters = \'abcdeghkmnpqrstuvwxyABCDEFGHKLMNPQRSTUVWXY3456789\'\n    $password = -join ((Get-Random -Count $length -InputObject $characters.ToCharArray()) | ForEach-Object { $_ })\n    return $password\n}\n\n# 遍歷每個學號並生成密碼\nforeach ($id in $studentIds) {\n    $password = Generate-RandomPassword\n    $results += "$id,$password"\n}\n\n# 將結果寫入檔案\n$results | Set-Content -Path "Y:\\tmp\\create_users\\2b_id_pass_name.txt"\n\nWrite-Host "學號和密碼已成功生成並儲存到 output.txt"\n \n create_users.ps1 \n # 讀取檔案\n$users = Get-Content -Path "Y:\\tmp\\create_users\\users.txt"\n\nforeach ($user in $users) {\n    # 分割行資料\n    $parts = $user -split ","\n    $account = $parts[0]\n    $password = $parts[1]\n    $name = $parts[2]\n\n    # 檢查用戶是否已存在\n    if (-not (Get-LocalUser -Name $account -ErrorAction SilentlyContinue)) {\n        # 創建用戶\n        New-LocalUser -Name $account -Password (ConvertTo-SecureString $password -AsPlainText -Force) -FullName $name -Description "User account for $name"\n        \n        # 創建用戶目錄\n        $userFolder = "C:\\Users\\$account"\n        New-Item -Path $userFolder -ItemType Directory -Force\n\n        # 設定目錄權限\n        $acl = Get-Acl $userFolder\n        $acl.SetOwner([System.Security.Principal.NTAccount]::new($account))\n        Set-Acl -Path $userFolder -AclObject $acl\n        \n        # 設定用戶對資料夾的訪問權限\n        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule($account, "FullControl", "Allow")\n        $acl.AddAccessRule($accessRule)\n        Set-Acl -Path $userFolder -AclObject $acl\n        \n        # 可選：將用戶添加到特定群組\n        # Add-LocalGroupMember -Group "Users" -Member $account\n    } else {\n        Write-Host "用戶 $account 已存在，跳過..."\n    }\n}\n \n install_and_setup_openssh_server.ps1 \n Get-WindowsCapability -Online | Where-Object Name -like \'OpenSSH*\'\n\nAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0\n\nStart-Service sshd\n\nSet-Service -Name sshd -StartupType \'Automatic\'\n\nNew-NetFirewallRule -Name sshd -DisplayName \'OpenSSH Server (sshd)\' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22\n\nGet-Service sshd\n \n \n', 'tags': '', 'url': 'Servers.html'}, {'title': 'Topics', 'text': 'HW Template: \n https://github.com/mdecp2024/hw-mdecycu \n https://mdecp2024.github.io/hw-mdecycu \n \n Topic 1: 基於瀏覽器的分散式版次管理與整合程式開發環境 (10%) \n USB 隨身碟: \n 下載可攜程式套件  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 以下兩個影片說明如何利用 Codespaces 維護個人的作業倉儲 (影片中以 mdecad2024 作業團隊為例, 配合計算機程式課程使用, 作業倉儲則位於 mdecp2024 團隊帳號下) \n Codespaces 維護作業倉儲教學片一: \n \n Codespaces 維護作業倉儲教學影片二: \n \n 1a w3 說明如何利用 Codespaces 維護作業網站: \n \n 以下兩個影片說明如何利用可攜程式環境在近端電腦維護作業倉儲內容: \n Localhost 維護作業倉儲教學影片一: \n \n Localhost 維護作業倉儲教學影片二: \n \n Jupyter \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 1 \n Topic 2: Python 的數列、判斷式與重複迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 2 and Part 3 \n Topic 3: Python 的數字、演算法與迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 4 and Part 5 \n Topic 4: 利用 Python 控制機電模擬系統 (20%) \n 利用\xa0 https://solvespace.com/ \xa0建立機械系統零組件 \n 利用  CoppeliaSim  建立機電模擬系統 \n 利用  Python  跨網路控制瀏覽器上的機電模擬系統 \n Final Report: 期末口頭與書面專題報告 (20%) \n', 'tags': '', 'url': 'Topics.html'}, {'title': 'Repository', 'text': '計算機程式課程中的作業將透過 Github Classroom 派送, 使用者必須登入 Github 後, 透過作業連結取得倉儲, 而此倉儲帶有採 Python Flask 框架所編寫的內容管理系統, 使用者可以利用 Github Codespaces 或近端的可攜程式套件進行網頁、網誌以及簡報檔的編輯與管理. \n 採 Github Codespaces 維護作業網站內容: \n \n 使用 免費方案 時, 必須了解相關限制 \n 使用 2 cores 的虛擬機器, 每個月只能使用 60 小時 \n 系統採用 Visual Studio Code, 支援多個終端機, 操作指令為 Linux \n 由作業倉儲端進入 Codespaces 介面, 使用者無需設定倉儲管理權限 \n 執行倉儲的動態網站後, 可在分組團隊間協同管理網站內容 \n 動態網站網址採亂數設定, 使用者無需修改網站的管理密碼 (內建為 admin) \n \n 採近端可攜程式環境維護網站內容: \n \n 可以在任何連網的 64 位元 Windows 操作系統中使用 \n 可以透過 Token 或 SSH 設定, 取得作業倉儲的管理權限 \n 若採用電腦的外部 IP 位址啟動, 執行倉儲後的動態網站, 必須修改管理密碼 \n \n 操作影片 Demo: \n', 'tags': '', 'url': 'Repository.html'}, {'title': 'Topic 1', 'text': '基於瀏覽器的分散式版次管理與整合程式開發環境 (10%) \n \n github_multi_site_version_control_dia.7z \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n Jupyter \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 1 \n 參考資料: \n https://www.youtube.com/@-kmolab9376/videos \n 討論: \n 目前的作業倉儲編輯程式, 使用 https adhoc 動態授權, 請深入了解若改用靜態 https 授權, 執行速度會快多少? \n 透過 ChatGPT 提問: 大約縮短 20%-50% 執行時間 \n 將 cmsimde\\wsgi.py 中的 adhoc https 改為靜態檔案授權: \n #flaskapp.app.run(host=ip, port=port, debug=True, ssl_context="adhoc")\nflaskapp.app.run(host=ip, port=port, debug=True, ssl_context=(\'cert.pem\', \'key.pem\')) \n 必須在倉儲根目錄提供 cert.pem 與 key.pem: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 使用 USB 隨身碟執行作業倉儲內容改版的速度, 與直接利用 C:\\ 固態硬碟執行的速度差多少? 假如可攜程式系統希望儘量使用 C:\\ 固態硬碟執行, 但需要作業倉儲與其他必須自行帶著的資料放入 USB 隨身碟, 該如何進行? \n 透過 ChatGPt 提問: 固態硬碟執行速度可能快 USB 3.0 隨身碟快 3-10 倍. \n 有關如何利用電腦輔助設計室中電腦固態硬碟提升執行速度, 請參考:  https://mde.tw/cp2024/content/cmsimde.html  中的說明. \n', 'tags': '', 'url': 'Topic 1.html'}, {'title': 'Codespaces', 'text': '登入 Github 帳號後, 可以至  https://github.com/codespaces  檢查所建立的 Codespaces. \n Codespaces 是附屬在 Github 倉儲下的雲端整合開發環境, 首次建立時系統會主動安裝特定的 Python 模組, 但若需要在 Codespaces 中執行 python main.py 啟動編輯網頁, 則必須利用: \n pip install flask flask_cors bs4 lxml pelican markdown gevent \n 安裝啟動 cmsimde 編輯網頁所需的 Python 模組. 安裝結束後, 就可以利用 python main.py 執行動態編輯網站, 而 python main2.py 則可以啟動目前位於 Codespaces 環境中的靜態網站. \n \n 當使用者完成動態網站內容的編輯後, 必須利用 Convert 將 /config/content.htm 進行分頁, 並將各頁面超文件檔案存入 content 目錄中. \n 若使用者在多個地方維護倉儲, 例如: Codespaces 與近端可攜程式環境, 執行動態網站編輯之前, 可以利用 git pull 從 Github 倉儲取下目前最新的版本資料. \n \n 由於 Codespaces 中的操作系統為 Linux, 進行編輯網頁啟動、靜態網站啟動與改版內容新增提交與推送時, 必須了解與 Linux 有關的基本概念: \n Codespaces 啟動後, 其終端機的回應 (Prompt) 會位於對應倉儲所在的目錄. \n 每一個檔案與目錄都利用 10 個字元來表示其屬性, 例如: \n drwxrwxrwx 或 -rwxrwxrwx 等十個字元, 其中第一個字元若為 d, 表示為目錄 (directory), 其餘 9 個字元則每一組三個字元, 分別從左至右, 依序表示為 user, group 或 other 等三種身分的 r (read) 權限、w (write) 權限 以及 x (execution) 權限, 也就是讀、寫以及執行的權限. \n 若要改變某一檔案或目錄的權限, 可以使用: \n chmod u+x acp 表示要針對 acp 檔案, 令 user 擁有執行 (x) 的權限. \n 利用 Codespaces 維護作業倉儲的相關資料與步驟: \n 執行環境 所需模組: \n \n 作業倉儲是採  cmsimde  網際內容管理搭建, 以 Python 編寫, 需要 flask flask_cors bs4 lxml pelican markdown 等模組才能執行. 有關這些模組的功能與用法可以透過 AI 詢問: "請用繁體中文用語回答, 以下 Python 模組分別有哪些功能? flask flask_cors bs4 lxml pelican markdown gevent". \n 在可攜程式環境中的 Python 10 已經事先安裝這些模組, 而 Codespaces 虛擬主機中, 使用者必須自行透過 "pip install flask flask_cors bs4 lxml pelican markdown gevent" 指令安裝這些模組, 其中的 pip 是 Python 模組安裝指令, 利用 pip install 加上模組名稱指定安裝. \n \n 如何啟動 編輯網站 , 如何觀看轉檔後的 靜態網站 : \n \n 一旦工作環境允許啟動作業倉儲中的編輯網站, 在 Codespaces 必須利用 python main.py 執行編輯網站, 並且利用 python main2.py 觀看當時已經編輯告一段落的靜態網站.\xa0 \n 假如是在近端, 則可以利用 python cmsimde/wsgi.py 直接啟動, 或者利用 cms 批次檔案啟動編輯網站. \n 另外, 在可攜程式環境則可以利用 python -m http.server 直接在倉儲根目錄觀看當時的靜態網站內容. \n \n 提交 時綁定的 Github 使用者 身分 , 以及是否具有 推送 該倉儲至 Github 的 權限 : \n \n 當使用者結束某一階段的作業網站編輯, 可以利用 git 指令將改版內容推向 Github 倉儲: \n 假如是在 Codespaces, 因為使用者必須登入 Github 才能使用 Codespaces, 因此執行 git add, git \xa0commit 與 git push 時, 無需表明身分, 也不用設定對提交推送倉儲的管理權限. \n 但是若在可攜程式環境中, 使用者必須透過 git config 設定提交身分,並且需要使用 https 或 SSH 方法設定對該目標倉儲的管理權限. \n \n 最後要提醒的是: 為了取分, 請在每週 上課前後至少各提交推送一次版本 , 而且要 具體說明 該次提交的改版摘要說明. \n \n 以下兩個影片說明如何利用 Codespaces 維護個人的作業倉儲 (影片中以 mdecad2024 作業團隊為例, 配合計算機程式課程使用, 作業倉儲則位於 mdecp2024 團隊帳號下) \n Codespaces 維護作業倉儲教學片一: \n \n Codespaces 維護作業倉儲教學影片二: \n \n', 'tags': '', 'url': 'Codespaces.html'}, {'title': 'Portable', 'text': '使用 Codespaces 雲端整合程式環境維護作業倉儲的好處是, 近端電腦只需要開啟瀏覽器, 不需要準備任何執行編輯網站的程式, 但是連線的電腦必須全時上網, 而且使用免費的 Github 帳號登入後, 啟動 Codespaces 的每月免費 core hours 目前只有 120 個單位, 以最小的 2 core 虛擬主機計, 每一個免費 Github 帳號每月可免費使用 Codespaces 的時數只有 60 小時. \n 使用時數受限的問題, 若利用近端電腦中的可攜程式套件維護作業倉儲, 只要在 git clone 作業倉儲到近端, 以及將改版的單一提交或多次提交 push 到 Github 時連網, 其餘使用者進行作業網頁編輯、轉靜態網頁、git add 以及 git commit, 都可以在不連網的情況下進行. \n 另外, 由於可攜程式環境已經事先安裝能夠執行網頁編輯所需的 Python 模組, 因此使用者只要將個人的作業倉儲 git clone 到 USB 隨身碟、桌上或筆電中的磁碟, 就可以直接啟動後進行網頁改版. \n 以下兩個影片說明如何利用可攜程式環境在近端電腦維護作業倉儲內容: \n Localhost 維護作業倉儲教學影片一: \n \n Localhost 維護作業倉儲教學影片二: \n \n', 'tags': '', 'url': 'Portable.html'}, {'title': 'class_materials', 'text': 'W6 工作環境: \n \n 使用 Teams 分享操作畫面 (在 IPv4 環境下有時分享畫面會自動跳開) \n 使用近端可攜程式環境維護 cp2024, 由於先前可能在其他地方加入新版本, 因此維護前先 git pull \n 目前 cp2024 使用 cmsimde 子模組, 學員的 mdecp2024 下作業倉儲則直接將 cmsimde 作為目錄 (差別?) \n 目前進度為 print() 與 for 迴圈的應用, 除了基本格式化字串列印, 相同程式邏輯, 可以將 3D 方塊放入機電模擬環境 \n \n \n 如何登入 Github 後, 顯示出帳號: \n how to show account after login to github? \n After logging into GitHub, you can view your account details and repositories by following these steps: \n 1. Log In: Go to [GitHub\'s website](https://github.com) and log in with your credentials. \n 2. Profile Icon: Click on your profile icon in the upper right corner of the page. \n 3. Your Profile: Select "Your profile" from the dropdown menu. This will take you to your profile page, where you can see your repositories, contributions, and other account details. \n 4. Repositories: To view your repositories, click on the "Repositories" tab on your profile page. This will list all the repositories you own and contribute to. \n 5. Settings: If you want to manage account settings, click on "Settings" in the dropdown under your profile icon. Here, you can update your profile information, manage notifications, and more. \n \n 1b w1 \n \n 作業 template:\xa0 https://mde.tw/cp2024_hw \xa0 \n 必備: \n 耳機 \n usb 隨身碟 (3.0 以上, 32 gb 以上) \n 使用者必須參考\xa0 https://mde.tw/cp2024/content/Office365.html \xa0完成: \n 登入 MS Teams 後透過 團隊代碼:\xa0 fqpabi8 進入上課畫面 \n 設法利用學號或帶有學號的字串, 作為 申請 Github  的帳號. \n 下週將透過  Github Classroom  派送作業倉儲, 使用者必須完成 Github 帳號中的兩段式認證, 若希望使用手錶認證, 可以使用  Authy app . \n \n 1a w1 \n \n 以下影片說明與 TCP/IP 有關的基本用法: \n \n 以下影片為 mdecad2024 org 有關的 Codespaces 維護作業網站的說明: \n \n 以下則為 mdecad2024 org 有關的可攜程式維護作業網站的說明： \n \n', 'tags': '', 'url': 'class_materials.html'}, {'title': 'Seat', 'text': '1a  座位表1 ,  分組座位表 \n 1b  座位表1 ,  分組座位表 \n \n 計算機程式 1a 座位表: \n \n 計算機程式 1b 座位表: \n \n 上述程式透過與 claude.ai 進行以下對話後產生： \n 問題:  https://mde.tw/2024/1a.txt 為一行學員的學號資料, 請用 Brython open().read() 讀取後, 利用 Canvas 在 id 為 brython_div 的超文件位置上, 採由上而下, 由右而左的次序, 用每一個學員除畫出學號外, 還加上外方框線, 且每一列共列出 9 位學員, 畫完後,以print() 印出 "done" 問: 怎麼只列出一位學員? (因為 AI 沒有用跳行隔開學員學號, 而是用 "," 隔開資料) 說明: 因為 AI 沒能正確解讀資料, 因此提供資料格式供其參考: 問:  40831154 40932134 41023249 41031136 41036112 這是前面五行資料, 請修改程式 說明: 接下來 AI 已經能夠正確解讀資料, 但因為提供錯誤的 html id 字串因此產生下列錯誤, File "<string>", line 8, in draw_students KeyError: brython_div 問: id 為 brython_div1, x 方向的框寬可以小一點, 否則最左邊顯示不出來 說明: 這時 AI 已經正確完成任務 (也就是修正各學員外框寬度後, 存為 group1), 但因所選的外框太寬, 因此最左邊的學號沒有完全顯示出來, 要求針對這個問題進行處理 問: 可不可以從最右邊開始, 第一列前三個與第二列前三個學員為同一組, 其框內背景請塗上同一個淡顏色辨識, 若至最後一列, 並沒有前三與後三作為同一組, 請就剩下的組員若少於 6 名則設為同一組, 若大於 6 則儘量平均方為兩組. 問: 是原則上同一列三位與下一列對齊的三位為同一組 問: 每一列不是有 9 位學員, 第二列也是有 9 位學員, 第一列的前三個學員與第二列的前三位為同一組, 接下來則是第一列的第 4, 5,6 位學員與第二列的第 4,5,6 位學員則也是同一組, 然後剩下的學員依照這個次序分組, 同一組的塗上相同的背景顏色. 最後因為可能剩下一個列的組員, 因此沒有辦法與下一列的組員進行分組, 因此只能就同一列每六位學員一組, 但若只剩下假設 9 位, 則一組 5 位同學,另一組 4 位, 表示一組至少要有 4 位學員的意思. 問: 原先的學員位置弄亂了, 目前第一列至第六列,只有從右邊算來前 6 位學員進行分組塗色, 各列 7,8,9 並沒有進行分組塗色 說明: 結果 AI 完成 group2 Brython 程式的編寫 \n 以下為 group1 Brython 程式碼: \n # 從 Brython 的瀏覽器模組中導入所需的功能\nfrom browser import document, ajax, html\n\n# 定義一個名為 `draw_students` 的函數，用於處理數據並進行繪製\ndef draw_students(evt):\n    # 從事件物件中獲取文字資料\n    data = evt.text\n    # 根據換行符將數據分割成學生名稱的列表\n    students = data.strip().split(\'\\n\')  # 以換行符分割\n    \n    # 檢查是否存在 ID 為 \'brython_div1\' 的 div，如果不存在則創建\n    if \'brython_div1\' not in document:\n        # 創建一個新的 DIV 元素，並設置其 ID\n        div = html.DIV(id=\'brython_div1\')\n        # 將新創建的 DIV 元素添加到文檔中\n        document <= div\n    \n    # 創建一個畫布元素，並設置其寬度和高度\n    canvas = html.CANVAS(width=900, height=600)\n    # 將畫布元素添加到 ID 為 \'brython_div1\' 的 DIV 中\n    document[\'brython_div1\'] <= canvas\n    # 獲取畫布的 2D 渲染上下文\n    ctx = canvas.getContext(\'2d\')\n    \n    # 設置初始繪製位置\n    x, y = 890, 20  # 稍微調整起始 x 位置\n    col_count = 0  # 計數器，用於跟踪當前列數\n    box_width = 80  # 設置每個學生姓名框的寬度\n    \n    # 利用迴圈取出每個學生姓名\n    for student in students:\n        student = student.strip()  # 去除多餘的空白字符\n        if not student:  # 如果學生姓名為空，則跳過\n            continue\n        \n        # 繪製學生姓名框的邊框\n        ctx.strokeRect(x-box_width, y-15, box_width, 30)\n        \n        # 設置繪製文字的字體大小\n        ctx.font = \'14px Arial\'  # 稍微減小字體大小\n        # 在指定位置繪製學生姓名\n        ctx.fillText(student, x-box_width+5, y+5)\n        \n        # 更新繪製位置，準備繪製下一個框\n        x -= box_width + 10  # 框之間的間距設為 10\n        col_count += 1  # 更新列計數器\n        \n        # 因為每一列有 9 台電腦\n        # 如果列計數器達到 9，則換行\n        if col_count == 9:\n            x = 890  # 重置 x 位置到最右側\n            y += 40  # 增加 y 位置，移動到下一行\n            col_count = 0  # 重置列計數器\n    \n    # 打印繪製的學生總數\n    print(f"Total students drawn: {len(students)}")\n    print("done")  # 打印“完成”信息\n\n# 定義一個名為 `load_data` 的函數，用於從指定 URL 加載數據\ndef load_data(url):\n    # 創建一個新的 AJAX 請求對象\n    req = ajax.ajax()\n    # 將 `draw_students` 函數綁定到 AJAX 請求的完成事件\n    # 表示隨後 AJAX 提出 request 完成之後\n    # 要求執行 draw_students 函式\n    req.bind(\'complete\', draw_students)\n    # 打開 AJAX 請求，指定請求類型為 GET，請求的 URL 和是否採非同步方式進行 request (True 表示採非同步)\n    req.open(\'GET\', url, True)\n    # 發送 AJAX 請求\n    req.send()\n\n# 調用 `load_data` 函數，從指定 URL 加載學生數據\nload_data(\'https://mde.tw/2024/1b.txt\')\n \n 以下為 group2 Brython 程式碼: \n from browser import document, ajax, html  # 從 Brython 的 browser 模組中導入 document（操作 HTML 文檔）、ajax（發送非同步請求）和 html（創建 HTML 元素）功能\nimport random  # 導入 Python 的 random 模組，用於生成隨機數字\n\ndef generate_pastel_color():\n    r = random.randint(200, 255)  # 生成一個介於 200 到 255 之間的隨機紅色通道值\n    g = random.randint(200, 255)  # 生成一個介於 200 到 255 之間的隨機綠色通道值\n    b = random.randint(200, 255)  # 生成一個介於 200 到 255 之間的隨機藍色通道值\n    return f\'rgb({r},{g},{b})\'  # 返回生成的柔和顏色的 RGB 字符串表示\n\ndef draw_students(evt):\n    data = evt.text  # 從 AJAX 請求事件對象中獲取伺服器返回的文本數據\n    students = data.strip().split(\'\\n\')  # 去除首尾空白並根據換行符分割成學生名單列表\n    \n    if \'brython_div1\' not in document:  # 檢查文檔中是否已存在 ID 為 \'brython_div1\' 的 DIV 元素\n        div = html.DIV(id=\'brython_div1\')  # 創建一個新的 DIV 元素，ID 設置為 \'brython_div1\'\n        document <= div  # 將創建的 DIV 元素添加到文檔中\n    \n    canvas = html.CANVAS(width=900, height=600)  # 創建一個寬 900 像素、高 600 像素的畫布元素\n    document[\'brython_div1\'] <= canvas  # 將畫布添加到 ID 為 \'brython_div1\' 的 DIV 中\n    ctx = canvas.getContext(\'2d\')  # 獲取畫布的 2D 渲染上下文，用於在畫布上進行繪製操作\n    \n    x, y = 890, 20  # 初始化起始繪製位置的 x 和 y 坐標\n    box_width = 80  # 設置每個學生姓名框的寬度為 80 像素\n    students_per_row = 9  # 每行顯示 9 名學生\n    group_size = 3  # 每組顏色的數量為 3\n    \n    def draw_student(student, x, y, color=None):\n        ctx.strokeRect(x-box_width, y-15, box_width, 30)  # 繪製學生姓名框的邊框\n        if color:  # 如果提供了顏色\n            ctx.fillStyle = color  # 設置填充顏色\n            ctx.fillRect(x-box_width+1, y-14, box_width-2, 28)  # 填充姓名框背景顏色\n        ctx.fillStyle = \'black\'  # 設置文字顏色為黑色\n        ctx.font = \'14px Arial\'  # 設置文字字體和大小\n        ctx.fillText(student, x-box_width+5, y+5)  # 在指定位置繪製學生姓名\n    \n    def draw_row(row_students, y, colors):\n        nonlocal x  # 宣告 x 為外部作用域中的變數，以便在內部函數中修改它\n        for i, student in enumerate(row_students):  # 用迴圈取出當前行的學生名單\n            color = colors[i // group_size]  # 根據索引分配顏色\n            draw_student(student, x, y, color)  # 繪製學生姓名框和姓名\n            x -= box_width + 10  # 更新 x 坐標以便繪製下一個學生的姓名框\n        x = 890  # 繪製完一行後，重置 x 坐標以便為下一行的繪製做好準備\n    \n    row_pairs = []  # 初始化一個空列表，用於儲存每兩行學生的配對\n    while len(students) >= students_per_row * 2:  # 當學生數量足夠形成至少兩行時\n        row_pairs.append((students[:students_per_row], students[students_per_row:students_per_row*2]))  # 添加兩行學生到配對列表\n        students = students[students_per_row*2:]  # 更新學生名單，去掉已處理的部分\n    \n    for row1, row2 in row_pairs:  # 遍歷每一對學生行\n        colors = [generate_pastel_color() for _ in range(3)]  # 為每對行生成三種隨機的柔和顏色\n        draw_row(row1, y, colors)  # 繪製第一行學生的姓名框\n        y += 40  # 更新 y 坐標，為下一行的繪製留出空間\n        draw_row(row2, y, colors)  # 繪製第二行學生的姓名框\n        y += 40  # 更新 y 坐標，為下一對行留出空間\n    \n    if students:  # 處理剩餘的學生\n        remaining = len(students)  # 獲取剩餘學生的數量\n        if remaining <= students_per_row:  # 如果剩餘學生不足一行\n            groups = (remaining + 3) // 4  # 確保至少有 4 人一組\n            colors = [generate_pastel_color() for _ in range(groups)]  # 生成所需數量的顏色\n            draw_row(students, y, colors * 3)  # 繪製剩餘學生的姓名框，並確保顏色數量足夠\n        else:  # 剩餘的學生足夠兩行但不足兩個完整行\n            colors = [generate_pastel_color() for _ in range(3)]  # 生成三種顏色\n            row1 = students[:students_per_row]  # 分配到第一行\n            row2 = students[students_per_row:]  # 分配到第二行\n            draw_row(row1, y, colors)  # 繪製第一行\n            y += 40  # 更新 y 坐標\n            draw_row(row2, y, colors)  # 繪製第二行\n    \n    print(f"Total students drawn: {len(data.strip().split(\'\\n\'))}")  # 輸出繪製的學生總數\n    print("done")  # 輸出完成訊息\n\ndef load_data(url):\n    req = ajax.ajax()  # 創建一個新的 AJAX 請求對象\n    req.bind(\'complete\', draw_students)  # 當請求完成時，綁定 draw_students 函數進行處理\n    req.open(\'GET\', url, True)  # 設置請求方法為 GET，並指定 URL 和異步標誌\n    req.send()  # 發送請求\n\nload_data(\'https://mde.tw/2024/1a.txt\')  # 加載指定 URL 的數據\n \n group1 Brython 假如不使用 AJAX, 直接利用 open().read() 讀取網站資料: \n # 從 Brython 的瀏覽器模組中導入所需的功能\nfrom browser import document, html\n\nurl = \'https://mde.tw/2024/1b.txt\'\ndata = open(url).read()\n\n# 定義一個名為 `draw_students` 的函數，用於處理數據並進行繪製\ndef draw_students(data):\n    # 根據換行符將數據分割成學生名稱的列表\n    students = data.strip().split(\'\\n\')  # 以換行符分割\n     \n    # 檢查是否存在 ID 為 \'brython_div1\' 的 div，如果不存在則創建\n    if \'brython_div1\' not in document:\n        # 創建一個新的 DIV 元素，並設置其 ID\n        div = html.DIV(id=\'brython_div1\')\n        # 將新創建的 DIV 元素添加到文檔中\n        document <= div\n     \n    # 創建一個畫布元素，並設置其寬度和高度\n    canvas = html.CANVAS(width=900, height=600)\n    # 將畫布元素添加到 ID 為 \'brython_div1\' 的 DIV 中\n    document[\'brython_div1\'] <= canvas\n    # 獲取畫布的 2D 渲染上下文\n    ctx = canvas.getContext(\'2d\')\n     \n    # 設置初始繪製位置\n    x, y = 890, 20  # 稍微調整起始 x 位置\n    col_count = 0  # 計數器，用於跟踪當前列數\n    box_width = 80  # 設置每個學生姓名框的寬度\n     \n    # 利用迴圈取出每個學生姓名\n    for student in students:\n        student = student.strip()  # 去除多餘的空白字符\n        if not student:  # 如果學生姓名為空，則跳過\n            continue\n         \n        # 繪製學生姓名框的邊框\n        ctx.strokeRect(x-box_width, y-15, box_width, 30)\n         \n        # 設置繪製文字的字體大小\n        ctx.font = \'14px Arial\'  # 稍微減小字體大小\n        # 在指定位置繪製學生姓名\n        ctx.fillText(student, x-box_width+5, y+5)\n         \n        # 更新繪製位置，準備繪製下一個框\n        x -= box_width + 10  # 框之間的間距設為 10\n        col_count += 1  # 更新列計數器\n         \n        # 因為每一列有 9 台電腦\n        # 如果列計數器達到 9，則換行\n        if col_count == 9:\n            x = 890  # 重置 x 位置到最右側\n            y += 40  # 增加 y 位置，移動到下一行\n            col_count = 0  # 重置列計數器\n     \n    # 打印繪製的學生總數\n    print(f"Total students drawn: {len(students)}")\n    print("done")  # 打印“完成”信息\n \ndraw_students(data) \n \n', 'tags': '', 'url': 'Seat.html'}, {'title': 'cmsimde', 'text': 'https://github.com/mdecycu/cmsimde  是一套利用 Python + Flask 編寫的網際內容管理系統, 將網頁編輯程式與靜態網站放在同一個倉儲中. \n Flask 啟動 https 連線可以採 adhoc 與使用 key.pem, cert.pem 等兩種方式, 其中採 key.pem, cert.pem 的執行無需每次連線都生成數位簽章, 因此速度較快. \n cert.pem 與 key.pem 可以利用可攜程式中的 openssl.exe 建立: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 放入倉儲根目錄, 並修改 cmsimde 目錄中的 wsgi.py: \n #!/usr/bin/python\n \n"""Flask startup script\n"""\n \nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__)))\n# import flaskapp at the same directory\nimport flaskapp\n \n# get uwsgi, ip and port variable values of flaskapp.py\nuwsgi = flaskapp.uwsgi\nip = flaskapp.ip\nport = flaskapp.dynamic_port\n \nif uwsgi:\n    # run on remote site\n    application = flaskapp.app\nelse:\n    # on localhost, on Linux or Mac need to use python3 wsgi.py to execute\n    #flaskapp.app.run(host=ip, port=port, debug=True, ssl_context="adhoc")\n    flaskapp.app.run(host=ip, port=port, debug=True, ssl_context=(\'cert.pem\', \'key.pem\')) \n 此外, 為了加快 USB 中編輯動態網站與生成靜態網站的速度, 可以每次啟動電腦後下載 python_2025_lite.7z 後解開至 C:\\, 使用 batch file 執行如下: \n @echo off\n \nREM 下載 python_2025_lite.7z\n \ncurl --user kmolab:kmolab --output C:\\Users\\%USERNAME%\\Downloads\\python_2025_lite.7z "http://229.cycu.org/python_2025_lite.7z"\n \nREM 解開壓縮檔案至 C:\\\n \n"C:\\Program Files\\7-Zip\\7z" x C:\\Users\\%USERNAME%\\Downloads\\python_2025_lite.7z -oC:\\ -y \n 並僅將 SSH 認證檔案、額外安裝的 Python 模組與 Github 倉儲放在 USB 隨身碟, 其餘執行檔案則使用 C:\\ 固態硬碟中下載或既有的檔案, 以加快執行速度, 其對應的啟動批次檔案 start_ipv6_hybrid.bat 如下: \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n \n%Disk%:\n \nREM 請先將 python_2025_lite 下載到 C:\\\nREM 除了個人作業倉儲與  ssh key 之外, 其他執行都使用 C:\\ 中的檔案\nset Local=C:\\python_2025_lite\\data\nREM for cadlab\nREM set NX_location="C:\\Program Files\\Siemens\\NX2312"\nset NX_location=E:\\NX2312_CAD\n \nREM python 執行將使用 C:\\, 但是額外的 Python 模組將存至隨身碟\nREM pip install <package> --target  Y:\\extra_python_modules, 但必須將此額外模組路徑納入 PYTHONPATH\n \nset HomePath=%Disk%:\\home_ipv6\nset HomeDrive=%Disk%:\\home_ipv6\nset Home=%Disk%:\\home_ipv6\nset USERPROFILE=%Disk%:\\home_ipv6\n \nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n \nset PYTHONPATH=%Local%\\Python310\\DLLs;%Local%\\Python310\\Lib;%Local%\\Python310\\Lib\\site-packages;%NX_location%\\NXBIN\\python;%Disk%:\\extra_python_modules;\nset PYTHONHOME=%Local%\\Python310\n \nREM for putty\nset GIT_SSH=%Local%\\PuTTY\\plink.exe\n \nREM 設定跟 Python 有關的命令搜尋路徑\nset path_python=%Local%\\Python310;%Local%\\Python310\\Scripts;\nREM 設定跟Git 有關的命令搜尋路徑\nset path_git=%Local%\\portablegit\\bin;\n\nREM proxy can not use with fossil scm\nREM set HTTP_PROXY=http://[2001:288:6004:xx::42]:3128\nREM set HTTPS_PROXY=http://[2001:288:6004:xx::42]:3128\n \nREM for PyRep\nset VREP_PATH=%Local%\\CoppeliaSim\n \nREM for execute scite directly\nset path_scite=%Local%\\wscite\\;\n \nREM for simExtZMQ\nset path_xsltproc=%Local%\\xsltproc;\n \nREM for OpenSSL\nSet OPENSSL_CONF=%Local%\\OpenSSL-Win64\\SSL\\openssl.cnf\nset path_openssl=%Local%\\OpenSSL-Win64\\bin;\n \npath=%Local%;%path_python%;%path_git%;%path_putty%;%path_scite%;%path_openssl%;%path%;\n \nREM for NX2312, must after path setup \nset SPLM_LICENSE_SERVER=29000@192.168.56.3\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%NX_location%\nset UGII_TMP_DIR=%Local%\\tmp\nset UGII_LIB_PATH=%NX_location%\\NXBIN\\python\nset ugii=%NX_location%\\ugii;%NX_location%\\nxbin;\npath = %ugii%;%path%\nREM Xcopy %Local%\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y\n \nREM start ugraf -nx\n \nREM python %Local%\\tmp\\nx_ex\\new_part.py\n \nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n \nstart /MIN %Local%\\wscite\\SciTE.exe\nstart /MIN %Local%\\wscite\\SciTE.exe\n \n \nExit \n \n', 'tags': '', 'url': 'cmsimde.html'}, {'title': 'Vocabulary', 'text': '這裡將要利用 Python 程式, 從電子書:  Learn Python with Jupyter  (5.6MB), 擷取出英文單字, 並建立查詢中英文字典的網頁. \n 所使用的 Python 模組為  textract  結合  poppler  中的 pdftotext.exe 工具, 先利用  extract_text_from_pdf.txt  將電子書的內容取出後, 再利用  check_vocabulary_from_cdit_net.txt  建立單字查詢超文件:  words_learn_python_with_jupyter.html \n 由於可攜程式套件  python_2025_lite.7z  中的 pip 版本高於 24.1, 導致無法正常安裝  textract  模組, 因此利用: \xa0 \n python get-pip.py pip==21.1.2 \n 將 pip 版本退至 21.1.2 後, 利用 pip install textract, 然後下載  poppler  工具, 讓 pdftotext.exe 可以在可攜程式環境的 path 中執行. \n \n \n', 'tags': '', 'url': 'Vocabulary.html'}, {'title': 'Windows', 'text': '使用 VPN 或位於校網, 下載  Windows 1809 ISO , 然後利用  Virtualbox  以虛擬主機安裝 Windows 操作系統. \n 其他教育版軟體下載:\xa0 https://software.nfu.edu.tw/ \xa0 \n 安裝完成後, 可以直接利用  win10_2024.vdi \xa0建立一個虛擬的 Windows 10 操作系統環境. 或者下載  win10_2024_vdi.7z , 使用已經配置 Firefox, 7zip, 以及\xa0 python_2025_lite.7z \xa0的虛擬主機檔案. \n 接下來就可以利用虛擬主機自行配置計算機程式所需的網路與 Python 可攜套件. \n 建立使用者: \n 利用指令建立 Windows 10 下的使用者帳號: \n 先利用管理者身分啟動一個 cmd (命令提示字元視窗) \n 利用 net user 帳號名稱 密碼 /add 指令, 建立使用者登入名稱為: 帳號名稱, 其登入密碼為: 密碼 \n 修改  uuid : \n 利用\xa0 VBoxManage.exe 修改 win10_2024.vdi 的 uuid, 因為在同一套 Virtualbox 上的各個虛擬主機檔案, 必須要有不同的 uuid. \n D:\\VirtualBox\\VBoxManage internalcommands sethduuid "c:\\tmp\\win10_2024.vdi" \n 下載安裝 SolidWorks 2023 教育版: \n 請參考電腦輔助設計實習課程中的  SolidWorks 頁面 說明. \n 虛擬主機上的網路卡設定: \n 希望虛擬主機可以上網, 但無需做為伺服器 -  採 NAT 設定 , 可以利用宿主 (實體 Windows 或 Linux 操作系統) 的網路連外, 但是外網電腦無法直接對此虛擬主機連線. \n 希望虛擬主機可以上網, 並且充當伺服器 -  採 Bridge Adaptor 設定 , 虛擬主機的網路卡位階與宿主的網路卡連線相當, 若宿主有兩片實體網路卡, 則虛擬主機可以將 Bridge Adaptor 轉接到第宿主的第二片實體網路卡, 可以取得與宿主相同的網路連線頻寬. \n 希望虛擬主機僅能與宿主網路連線, 不會受到外部網路干擾 -  採 Host-Only Adaptor 設定 , 虛擬主機僅能與宿主透過內部的網路設定連線, 虛擬主機無法對外連線. \n \n \n \n', 'tags': '', 'url': 'Windows.html'}, {'title': 'Environment', 'text': '說明如何利用 ShareX 與 Zoomit 拍攝電腦操作流程影片: \n \n 示範如何加入 Brython 頁面, 並用來編寫 print 與 for 迴圈相關程式: \n \n 說明如何使用可攜程式維護作業網站: \n \n check_1a_w7_html \n check_1b_w7_html \n \n 執行 Python 的環境: \n \n Brython 環境:\xa0 https://mde.tw/cp2024/content/Brython.html \xa0 \n 可攜環境的 SciTE 編輯器 \n 可攜環境的命令提示字元視窗 \n Jupyter lab \n Codespaces 環境中的 Visual Studio Code \n \n \n Brython 頁面超文件:\xa0 brython_html.txt \n \n brython_functions.dia \n Strings, input(), and print() \n 首先必須瞭解\xa0 Python 變數命名法則: \n 必須以英文字母或 _ 作為開頭, 隨後可以接上任何數字、英文字母或 _ \n 但變數名稱區分英文字母的大小寫, 變數也可以使用中文命名, 但一般並不建議使用英文以外的多 byte 語系命名. \n String 為字串, 可以用單引號、雙引號或三引號隔開. 例如: \n "this is a string\'s " 使用雙引號將字串區隔\n\n\'this is a string\' 使用單引號將字串區隔\n\n當字串超過一行時, 可以使用三引號:\n\n\'\'\'\n\n這裡面是用來說明程式目的或紀錄\n\n相關事項的多行文字\n\n\'\'\' \n print 與 for 重複迴圈 \n help(print) \n Help on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=\' \', end=\'\\n\', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream. \n help(range) \n Help on class range in module builtins:\n\nclass range(object)\n |  range(stop) -> range object\n |  range(start, stop[, step]) -> range object\n |  \n |  Return an object that produces a sequence of integers from start (inclusive)\n |  to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\n |  start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\n |  These are exactly the valid indices for a list of 4 elements.\n |  When step is given, it specifies the increment (or decrement).\n |  \n |  Methods defined here:\n |  \n |  __bool__(self, /)\n |      True if self else False\n |  \n |  __contains__(self, key, /)\n |      Return key in self.\n |  \n |  __eq__(self, value, /)\n |      Return self==value.\n |  \n |  __ge__(self, value, /)\n |      Return self>=value.\n |  \n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |  \n |  __getitem__(self, key, /)\n |      Return self[key].\n |  \n |  __gt__(self, value, /)\n |      Return self>value.\n |  \n |  __hash__(self, /)\n |      Return hash(self).\n |  \n |  __iter__(self, /)\n |      Implement iter(self).\n |  \n |  __le__(self, value, /)\n |      Return self<=value.\n |  \n |  __len__(self, /)\n |      Return len(self).\n |  \n |  __lt__(self, value, /)\n |      Return self<value.\n |  \n |  __ne__(self, value, /)\n |      Return self!=value.\n |  \n |  __reduce__(...)\n |      Helper for pickle.\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  __reversed__(...)\n |      Return a reverse iterator.\n |  \n |  count(...)\n |      rangeobject.count(value) -> integer -- return number of occurrences of value\n |  \n |  index(...)\n |      rangeobject.index(value) -> integer -- return index of value.\n |      Raise ValueError if the value is not present.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  start\n |  \n |  step\n |  \n |  stop \n 與 ChatGPT 對話: \n 可以解釋一下help(range) 傳回來的內容嗎? \n 將 help(range) 傳回的內容貼給 ChatGPT, 然後問: \n 可以舉例詳細說明以下 help(range) 傳回來的內容嗎? 然後貼上 help 傳回的資料. \n 詢問 for i in range(): \n 如何解釋 Python 中的 for i in range(5): \n 如何解釋 range(5) ? \n range(5) 是數列嗎? \n 能夠生成從 0 到 4 的整數序列, 所以可以稱 range(5) 為甚麼? \n 請舉 10 個可以協助使用者理解 for range 與 print 等關鍵字的範例 \n 請用 Python 的 for 跟 print 印出五行的 * 排列成的三角形金字塔, 也就是 * 在最中間, 第二行為正中央的 *** 然後第三行 *****, 總共五行. \n 請詳細解釋你的解法過程 \n 問題分析\n\n我們希望生成一個由星號 * 組成的金字塔，總共 5 行，並且使星號在每一行中間對齊。金字塔的形狀如下：\n\n    *\n   ***\n  *****\n *******\n*********\n\n解法步驟\n\n    設定行數： 我們首先定義金字塔的行數。這裡我們設置 n = 5，代表金字塔有 5 行。\n\n    使用 for 迴圈： 我們將使用 for 迴圈來迭代每一行。range(n) 會生成從 0 到 4 的整數，對應於每一行的索引。\n\n    計算空格數： 為了使星號在每一行中間對齊，我們需要在星號前面印出一些空格。\n        在第 i 行，前面需要印出 n - i - 1 個空格。這樣可以確保每一行的星號都在金字塔的中間位置。\n        例如，在第 0 行（第一行）需要 4 個空格，在第 1 行需要 3 個空格，以此類推。\n\n    計算星號數： 每一行的星號數量是 2 * i + 1。\n        在第 0 行有 1 個星號，第一行有 3 個星號，第二行有 5 個星號，依此類推，這樣的模式使得每行的星號數量都是奇數並且增加。\n\n    印出結果： 使用 print() 函數印出計算得出的空格和星號。在第一個 print 中使用 end=\'\' 是為了避免換行，使得空格和星號能在同一行內輸出。\n\n程式碼實現\n\n以下是完整的程式碼和註解：\n\npython\n\nn = 5  # 總共的行數\n\nfor i in range(n):  # 對於每一行\n    # 印出空格\n    print(\' \' * (n - i - 1), end=\'\')  # 在每行前面印出空格\n    # 印出星號\n    print(\'*\' * (2 * i + 1))  # 每行印出 2*i + 1 個星號\n\n執行結果\n\n當你執行這段程式碼時，它會輸出一個對稱的金字塔，每一行的星號數量和位置都符合我們的要求。 \n help_print.txt \n help_range.txt \xa0( 在 Brython 環境執行 ) \n triangle_star_2.txt \xa0( 在 Brython 環境執行 ) \n \n \n coppeliasim_python.dia \n 在 AI 以及積極學習的動機下 (查英文單字、練習英打、學會與 AI 互動), 儘快了解\xa0 zmq_remote_api_ex.7z \n 利用 Python 將正方體物件排列進入 CoppeliaSim 模擬場景:  zmq_remote_api_ex_cube_triangle.7z \n 機械設計工程師學習計算機程式的目的之一: 設計與模擬運算, 希望在產品零組件實體製作之前, 可以事先了解或評量設計流程各階段事物的特性, 並提供關鍵設計尺寸進行客製化調控. \n CoppeliaSim API constants:  https://manual.coppeliarobotics.com/en/apiConstants.htm \n 在模擬場景中的 cubes 排列: \n \n 在瀏覽器中的 cubes 排列: \n \n 操作步驟: \n \n 下載\xa0 python_2025_lite.7z \xa0(可攜程式環境) \n 下載 \xa0 zmq_remote_api_ex_cube_triangle.7z \xa0(利用 Python 控制模擬場景中的物件) \n 進入可攜程式環境中 data/CoppeliaSim 目錄, 開啟 coppeliaSim.exe (機電整合模擬程式,  原始碼 ) \n 啟動可攜程式環境, 雙點擊 start_ipv6.bat, 系統會啟動四個命令列, 兩個 SciTE 編輯器 \n 執行場景控制程式前, 先處理操作系統的防火牆, 將下列指令存為 .bat 檔案後, 以管理員身分執行, 以便開啟 23000-23050 埠號進出: \n netsh advfirewall firewall add rule name="allow_23000-23050" dir=in action=allow protocol=TCP localport=23000-23050 netsh advfirewall firewall add rule name="allow_23000-23050" dir=out action=allow protocol=TCP localport=23000-23050 \n 開啟 CoppeliaSim 中的視覺串流伺服器: Modules - Connectivity - Visualization stream \n 利用 SciTE 開啟\xa0put_cubes_into_scene_1.py, 利用 Tools - Go 執行操控程式 \n 使用者可以透過瀏覽器, 以模擬場景所在電腦的 IP, 且埠號為 23020 觀看模擬場景 \n \n allow_23000-23050_in_out.txt  (存為 .bat 並以管理者身分執行) \n 詢問 ChatGPT, 希望讓\xa0 put_cubes_into_scene_1.py 中的所有 cubes 擺放後, 接著能夠全數朝負 Y 方向緩慢移動: \n 提問內容: "以下為 CoppeliaSim ZMQ remote API Python 程式, 請在生成 cute 列隊之後, 設法讓所有 cubes 緩緩朝負 Y 的方向移動:" 隨後加上的程式碼 \n 接著測試是否可以得到正確的答案? \n \n 1a site and repo \n 1b site and repo', 'tags': '', 'url': 'Environment.html'}, {'title': 'String', 'text': 'https://mde.tw/cp2024/downloads/learn_python_with_jupyter.pdf#chapter.1 \n 在 Python 中，字串（strings）就是用引號括起來的文本。它們是處理文字數據的基本方式。字串可以用單引號 (\')、雙引號 (")，或三重引號 (\'\'\' 或 """) 括起來。這些引號的使用方式有各自的特點和用途： 1. 單引號 (\') 單引號用於定義簡單的字串，適合沒有包含單引號字符的情境。 python # 定義一個單引號字串 single_quote_string = \'Hello, World!\' print(single_quote_string) 2. 雙引號 (") 雙引號也用於定義字串，它們的主要好處是當字串中包含單引號時，可以避免使用轉義字符。 python # 定義一個雙引號字串 double_quote_string = "Python\'s syntax is simple." print(double_quote_string) 3. 三重引號 (\'\'\' 或 """) 三重引號用於定義多行字串，也可以用於包含單引號和雙引號的情境。 python # 使用三重單引號定義多行字串 multi_line_string = \'\'\'This is a string that spans multiple lines. It can also include \'single\' and "double" quotes.\'\'\' print(multi_line_string) # 使用三重雙引號定義多行字串 another_multi_line_string = """Here is another example of a multi-line string. It also allows for \'single\' and "double" quotes.""" print(another_multi_line_string) 常見字串操作 \xa0\xa0\xa0 拼接字串 \xa0\xa0\xa0 使用 + 來拼接多個字串。 \xa0\xa0\xa0 python greeting = "Hello, " + "World!" print(greeting) 重複字串 使用 * 來重複字串。 python echo = "Hello! " * 3 print(echo) 字串長度 使用 len() 函數來獲取字串的長度。 python length = len("Hello, World!") print(length)\xa0 # 13 字串方法 Python 字串有許多內建的方法，如 upper(), lower(), strip(), replace(), find() 等。 python # 轉換為大寫 upper_case = "hello".upper() print(upper_case)\xa0 # "HELLO" # 移除首尾空白字符 stripped_string = "\xa0\xa0 text with spaces\xa0\xa0 ".strip() print(stripped_string)\xa0 # "text with spaces" # 替換字串中的字符 replaced_string = "hello world".replace("world", "Python") print(replaced_string)\xa0 # "hello Python" 格式化字串 使用 f-strings（Python 3.6 及更高版本）或 format() 方法進行格式化。 python \xa0\xa0\xa0 name = "Alice" \xa0\xa0\xa0 age = 30 \xa0\xa0\xa0 formatted_string = f"Name: {name}, Age: {age}" \xa0\xa0\xa0 print(formatted_string) \xa0\xa0\xa0 # 使用 format() 方法 \xa0\xa0\xa0 formatted_string = "Name: {}, Age: {}".format(name, age) \xa0\xa0\xa0 print(formatted_string) 結論 字串是 Python 中處理文字的基本單位，無論是單行還是多行，都可以用不同的引號來表示。了解如何操作字串是掌握 Python 的重要基礎。 \n', 'tags': '', 'url': 'String.html'}, {'title': 'Topic 2', 'text': 'Python 的數列、判斷式與重複迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 2 and Part 3 \n \n', 'tags': '', 'url': 'Topic 2.html'}, {'title': 'Topic 3', 'text': 'Python 的數字、演算法與迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 4 and Part 5 \n \n', 'tags': '', 'url': 'Topic 3.html'}, {'title': 'Topic 4', 'text': '利用 Python 控制機電模擬系統 (20%) \n 利用\xa0 https://solvespace.com/ \xa0建立機械系統零組件 \n 利用  CoppeliaSim  建立機電模擬系統 \n 利用  Python  跨網路控制瀏覽器上的機電模擬系統 \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n', 'tags': '', 'url': 'Topic 4.html'}, {'title': 'CAD', 'text': 'Solvespace \n https://solvespace.com/ \xa0 \n NX \n https://plm.sw.siemens.com/en-US/nx/ \xa0 \n NXOpen in Python \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n CoppeliaSim \n cd2023_pj3ag4_zmq_football_4.7.7z \n cad2024_foosball_with_ball_python_script.7z \n \n', 'tags': '', 'url': 'CAD.html'}, {'title': 'CoppeliaSim', 'text': '下載相容於 IPv6 的 CoppeliaSim 4.7.0 rev4:  CoppeliaSim_Edu_4.7.0_rev4_for_2024Fall.7z , 已經內建於  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n https://manual.coppeliarobotics.com/en/versionInfo.htm \n user settings file is C:\\Users\\%USERNAME%\\AppData\\Roaming/CoppeliaSim/usrset.txt \n CoppeliaSim 4.5.1 與 4.7.1 使用 ZMQ RemoteAPI Python 程式的差異: \n \n zmqRemoteApi 模組名稱改為 coppeliasim_zmqremoteapi_client \n sim 物件中的 sim.setJointForce() 方法已經失效, 必須改用 sim.setJointTargetForce() \n \n # zmqRemoteApi_IPv6 為將 zmq 通訊協定修改為 IPv4 與 IPv6 相容\n# pip install pyzmq cbor keyboard\n# for 4.5.1\n#from zmqRemoteApi_IPv6 import RemoteAPIClient\n# for 4.7.1\nfrom coppeliasim_zmqremoteapi_client import RemoteAPIClient\nimport time\nimport math\nimport keyboard\n\n# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線\nclient = RemoteAPIClient(\'localhost\', 23000)\n# 以 getObject 方法取得場景物件\nsim = client.getObject(\'sim\')\nbox = sim.getObject(\'/box\')\n\n# 啟動模擬\nsim.startSimulation()\n# 建立尺寸數列, 分別定義 x, y, z 方向尺寸\nx = 0.2\ny = 0.2\nz = 0.1\nsize = [x, y, z]\n\n# 利用 size 數列, 建立圓柱物件, 2 代表 cylinder\n# 8 表示 respondable, 1 為 質量\ndigit1_handle = sim.createPureShape(2, 8, size, 1, None)\n# 將圓柱物件命名為 digit1, 若用於機械計分可做為個位數轉盤\n# 之後可再導入帶有數字組立的外型零件\nsim.setObjectAlias(digit1_handle, \'digit1\')\n# 轉角單位為徑度\nsim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])\n# 起始物件中心位於 [0, 0, 0], 為了位於地板, 往 z 提升一個半徑高度\nsim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])\n\n# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity\njoint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)\nsim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)\nsim.setObjectAlias(joint1_handle, \'joint1\')\n\n# 取得 cylinder 的位置座標\ndigit1_pos = sim.getObjectPosition(digit1_handle, -1)\njoint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]\n\n# 將 joint1 至於 cylinder 中心\nsim.setObjectPosition(joint1_handle, -1, joint1_pos)\n# 取得 digit1_handle 的方位\ndigit1_ori = sim.getObjectOrientation(digit1_handle, -1)\n# 將 joint1_handle 方位與 digit1 對齊\nsim.setObjectOrientation(joint1_handle, -1, digit1_ori)\n\n# 將 joint1 置於 box 上\nsim.setObjectParent(joint1_handle, box, True)\n# 將 cylinder 置於 joint1 上\nsim.setObjectParent(digit1_handle, joint1_handle, True)\n\n# 鎖定 joint1\n# for 4.5.1\n#sim.setJointForce(joint1_handle, float(\'inf\'))\n# for 4.7.1\nsim.setJointTargetForce(joint1_handle, float(\'inf\'))\n\nprint("基本場景建立完成!")\n\n# 設定主迴圈\nwhile True:\n    # 設定 joint1 目標速度\n    sim.setJointTargetVelocity(joint1_handle, 10)\n    # 讓 coppeliasim 有時間按照設定讓 joint1 旋轉\n    time.sleep(0.01) \n\n    if keyboard.is_pressed(\'q\'):\n        # 可以按下 q 鍵跳出重複執行迴圈\n        break\n\n# 終止模擬\nsim.stopSimulation()\n\n \n \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'Python', 'text': 'Python 執行環境 \n Brython (全球資訊網上的 Python) \n Github Codespaces \n Windows 操作系統 \n 制式安裝 (VSCode and SciTE) \n 可攜設定 (VSCode and SciTE) \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n kmolab_ex.7z  (314MB) \n Ubuntu 操作系統 \n Types : Integers, Floats, Strings and Booleans \n Type Conversion \n Variables and Assignment \n Arithmetic Operators \n Comparison Operators \n Logical Operators \n Conditional Statements (if, elif, else) \n Loops (for, while) \n break, continue and pass \n Lists \n Tuples \n Sets \n Dictionaries \n Defining and Calling Functions \n Arguments and Return Values \n Local and Global Variables \n Importing  Modules \n Standard Library \n https://github.com/TheAlgorithms/Python \xa0 \n nxopen_base_and_center_pole_python.txt \n qrcode \n https://en.wikipedia.org/wiki/QR_code \n https://www.funcode-tech.com/QR_app.html \n # pip install qrcode matplotlib\nimport qrcode\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n#img=qrcode.make(\'20240101;5745632912;Steel;---;---\')\nimg=qrcode.make(\'虎尾科大機械設計工程系\')\nimg.save(\'qrcode_ex1.png\')\nimg = mpimg.imread(\'qrcode_ex1.png\')\nplt.imshow(img)\nplt.show() \n pdf \n pip install pypdf2 \n split pdf file: \n # pypdf2_split.py\nimport os\nfrom PyPDF2 import PdfWriter, PdfReader\n\npdfReader = PdfReader(open("Learn_Autodesk_Inventor_2018_Basics.pdf", "rb"))\ninformation = [("inventor",18,45)]\n \nfor page in range(len(information)):\n    pdf_writer = PdfWriter()\n    start = information[page][1]\n    end = information[page][2]\n    while start<=end:\n        pdf_writer.add_page(pdfReader.pages[start-1])\n        start+=1\n    if not os.path.exists("./"):\n        os.makedirs(savepath)\n    output_filename = \'{}_{}_page_{}.pdf\'.format(information[page][0],information[page][1], information[page][2])\n    with open(output_filename,\'wb\') as out:\n        pdf_writer.write(out)\nprint("已經完成 pdf 切割與存檔") \n combine pdf file: \n import os\nfrom PyPDF2 import PdfWriter, PdfReader\n\npdf_write_object = PdfWriter()\n\npdfFileNames = ["inventor1.pdf", "inventor2.pdf"]\nnewFileName = "inventor"\nfilenameString = ""\n\nfor filename in pdfFileNames:\n    pdf_read_object = PdfReader(open(filename, "rb"))\n    filenameString += filename + ", "\n    for page in range(len(pdf_read_object.pages)):\n        pdf_write_object.add_page(pdf_read_object.pages[page])\n \nfinal_file_object = open(newFileName + ".pdf", \'wb\')\npdf_write_object.write(final_file_object)\nfinal_file_object.close()\n\nprint("已經將 " + filenameString+ " 合併為: "+ newFileName + ".pdf")\n \n Pelican Blog md generator \n https://github.com/mdecycu/pelican_md_generator \n NXOpen Python \n 機械設計工程師若能夠看得懂  nxopen_base_and_center_pole_python.txt , 是否能夠將程式碼改寫為 Function 或 Class 架構, 以方便用程式方法建立機電系統設計中的參數式零組件? \n ZMQ remote API Python for CoppeliaSim \n 可遠端透過 Python 程式控制機電模擬系統的  cd2023_pj3ag4_zmq_football4.7z , 則牽涉 ZMQ、IPv4、IPv6 與  asyncio  模組. \n Python for Webots \n Python 程式也能用來控制 Webots 機電模擬系統:  https://cyberbotics.com/doc/guide/using-python \n Python 與 CAD 有關的其他應用 \n https://pypi.org/project/python-solvespace/ \n https://github.com/jimy-byerley/pymadcad \n', 'tags': '', 'url': 'Python.html'}, {'title': 'References', 'text': '已知: \n \n 修課學員經由 @nfu.edu.tw 網域, 可利用"學號@nfu.edu.tw"經由  https://login.microsoftonline.com/  登入 MS 365. \n 登入後, 使用者可以利用" 應用程式註冊 "建立應用程式 \n 所註冊的延伸應用程式則可以利用 Microsoft Online 主機所提供的 OAuth2 API 程式庫, 取得登入者的 profile \n 經由上列步驟取得登入者的 profile 後, 延伸應用程式可設法讀取課程學員的作業倉儲與網站連結 \n 當每一階段的學員作業網頁完成後, 若再經由亂數方法, 隨機分配給每一位學員 10 個除自己以外的學員作業網站進行評分, 即可根據既定的評分基準完成自評 \n 隨機分配的學員作業網址可利用 email 寄出, 而評分回報則可利用 MS 365 的 Forms 表單取回 \n \n 以下為上列流程的 step 1 測試程式 ( teams_oauth2_flask_py.txt ): \n from flask import Flask, redirect, request, session, url_for\nimport requests\nimport json\n\napp = Flask(__name__)\napp.secret_key = \'your_secret_key\'  # 用於 Flask session 的秘密金鑰\n\n# 替換成你的 Azure AD 應用程式資訊\n\'\'\'\nCLIENT_ID 為"應用程式 (用戶端) 識別碼"\nCLIENT_SECRET 則為"憑證及秘密"中"用戶端密碼"的"值"\n\'\'\'\nCLIENT_ID = \'id\'\nCLIENT_SECRET = \'secret\'\nTENANT_ID = \'id\'\nAUTHORITY = f\'https://login.microsoftonline.com/{TENANT_ID}\'\nREDIRECT_URI = \'http://localhost:8000/callback\'\nSCOPE = \'User.Read\'\n\n# 用於登錄和取得授權碼\n@app.route(\'/\')\ndef index():\n    auth_url = (f\'{AUTHORITY}/oauth2/v2.0/authorize\'\n                f\'?client_id={CLIENT_ID}\'\n                f\'&response_type=code\'\n                f\'&redirect_uri={REDIRECT_URI}\'\n                f\'&response_mode=query\'\n                f\'&scope={SCOPE}\')\n    return redirect(auth_url)\n\n# 處理回調和交換授權碼\n@app.route(\'/callback\')\ndef callback():\n    code = request.args.get(\'code\')\n    token_url = f\'{AUTHORITY}/oauth2/v2.0/token\'\n    token_data = {\n        \'grant_type\': \'authorization_code\',\n        \'code\': code,\n        \'redirect_uri\': REDIRECT_URI,\n        \'client_id\': CLIENT_ID,\n        \'client_secret\': CLIENT_SECRET,\n        \'scope\': SCOPE\n    }\n    token_r = requests.post(token_url, data=token_data)\n    token_r.raise_for_status()\n    tokens = token_r.json()\n    session[\'access_token\'] = tokens[\'access_token\']\n    return redirect(url_for(\'profile\'))\n\n# 使用訪問令牌呼叫 Microsoft Graph API 來獲取用戶資料\n@app.route(\'/profile\')\ndef profile():\n    access_token = session.get(\'access_token\')\n    if not access_token:\n        return redirect(url_for(\'index\'))\n\n    headers = {\n        \'Authorization\': f\'Bearer {access_token}\',\n        \'Content-Type\': \'application/json\'\n    }\n    graph_url = \'https://graph.microsoft.com/v1.0/me\'\n    graph_r = requests.get(graph_url, headers=headers)\n    graph_r.raise_for_status()\n    user_info = graph_r.json()\n    user_email = str(user_info["mail"])\n    user_id = user_email.split("@")[0]\n    session["user_id"] = user_id\n    # 登出 MS Online 並重定向回首頁\n    # 返回 HTML 及 JavaScript 以進行自動登出\n    return (f\'Hello, {user_id} <br>\'\n            f\'<script type="text/javascript">\'\n            f\'  window.location = "https://login.microsoftonline.com/common/oauth2/v2.0/logout";\'\n            f\'</script>\')\n\n@app.route(\'/userid\')\ndef userid():\n    return session["user_id"]\n    \n\n# 登出功能\n@app.route(\'/logout\')\ndef logout():\n    # 清除 session 中的訪問令牌\n    session.pop(\'access_token\', None)\n    # 重定向到 MS Online 登出 URL\n    return redirect(\'https://login.microsoftonline.com/common/oauth2/v2.0/logout\')\n\nif __name__ == \'__main__\':\n    app.run(debug=True, port=8000)\n \n 以下則為寄信範例: \n import requests\nimport json\n\n# 替換為你的應用程式資訊\nCLIENT_ID = \'your_client_id\'\nCLIENT_SECRET = \'your_client_secret\'\nTENANT_ID = \'your_tenant_id\'\nAUTHORITY = f\'https://login.microsoftonline.com/{TENANT_ID}\'\nTOKEN_URL = f\'{AUTHORITY}/oauth2/v2.0/token\'\nSCOPE = \'https://graph.microsoft.com/.default\'\n\n# 獲取 OAuth2 訪問令牌\ndef get_access_token():\n    token_data = {\n        \'grant_type\': \'client_credentials\',\n        \'client_id\': CLIENT_ID,\n        \'client_secret\': CLIENT_SECRET,\n        \'scope\': SCOPE\n    }\n    token_r = requests.post(TOKEN_URL, data=token_data)\n    token_r.raise_for_status()\n    tokens = token_r.json()\n    return tokens[\'access_token\']\n\n# 發送電子郵件\ndef send_email(access_token, to_address, subject, body):\n    headers = {\n        \'Authorization\': f\'Bearer {access_token}\',\n        \'Content-Type\': \'application/json\'\n    }\n    email_data = {\n        "message": {\n            "subject": subject,\n            "body": {\n                "contentType": "Text",\n                "content": body\n            },\n            "toRecipients": [\n                {\n                    "emailAddress": {\n                        "address": to_address\n                    }\n                }\n            ]\n        },\n        "saveToSentItems": "true"\n    }\n    email_url = \'https://graph.microsoft.com/v1.0/me/sendMail\'\n    response = requests.post(email_url, headers=headers, json=email_data)\n    response.raise_for_status()\n    print("Email sent successfully!")\n\nif __name__ == "__main__":\n    token = get_access_token()\n    send_email(token, \'recipient@example.com\', \'Test Subject\', \'This is the email body.\')\n \n \n 以下利用 ChatGPT 4omini 進行對話: \n 問: \n 使用 python + flask 開發一個簡單的資料庫程式, 並使用 SQLite, 目前表單有使用者學號以及其 github 帳號, 還有一個備註欄位, 只需要 add, query, update 與 delete 功能, 該如何進行? \n 答: \n 1. 安裝 Flask 和 SQLite 首先，確保你已經安裝了 Flask 和 SQLite。如果你還沒有安裝，請使用以下命令： \n pip install Flask\n \n SQLite 通常已經隨 Python 安裝，不需要額外安裝。如果你需要 SQLite 的 Python 模組，可以使用以下命令： \n pip install sqlite3\n \n 2. 建立 Flask 應用程式 \n 應用程式結構 \n flask_app/\n│\n├── app.py\n├── schema.sql\n└── templates/\n    ├── index.html\n    ├── add.html\n    ├── update.html\n    └── query.html\n \n schema.sql — 定義 SQLite 資料表 在 schema.sql 文件中，定義 SQLite 資料表結構： \n CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    student_id TEXT NOT NULL UNIQUE,\n    github_account TEXT NOT NULL,\n    notes TEXT\n);\n \n app.py — Flask 應用程式 在 app.py 中，設置 Flask 應用程式並建立 CRUD 功能： \n from flask import Flask, request, redirect, url_for, render_template\nimport sqlite3\n\napp = Flask(__name__)\n\nDATABASE = \'database.db\'\n\ndef get_db():\n    conn = sqlite3.connect(DATABASE)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    with app.app_context():\n        db = get_db()\n        with open(\'schema.sql\', \'r\') as f:\n            db.executescript(f.read())\n        db.commit()\n\n@app.route(\'/\')\ndef index():\n    return render_template(\'index.html\')\n\n@app.route(\'/add\', methods=[\'GET\', \'POST\'])\ndef add_user():\n    if request.method == \'POST\':\n        student_id = request.form[\'student_id\']\n        github_account = request.form[\'github_account\']\n        notes = request.form.get(\'notes\', \'\')\n\n        db = get_db()\n        db.execute(\'INSERT INTO users (student_id, github_account, notes) VALUES (?, ?, ?)\',\n                   (student_id, github_account, notes))\n        db.commit()\n        return redirect(url_for(\'index\'))\n\n    return render_template(\'add.html\')\n\n@app.route(\'/update/<int:user_id>\', methods=[\'GET\', \'POST\'])\ndef update_user(user_id):\n    db = get_db()\n    if request.method == \'POST\':\n        student_id = request.form[\'student_id\']\n        github_account = request.form[\'github_account\']\n        notes = request.form.get(\'notes\', \'\')\n\n        db.execute(\'UPDATE users SET student_id = ?, github_account = ?, notes = ? WHERE id = ?\',\n                   (student_id, github_account, notes, user_id))\n        db.commit()\n        return redirect(url_for(\'index\'))\n\n    user = db.execute(\'SELECT * FROM users WHERE id = ?\', (user_id,)).fetchone()\n    return render_template(\'update.html\', user=user)\n\n@app.route(\'/delete/<int:user_id>\')\ndef delete_user(user_id):\n    db = get_db()\n    db.execute(\'DELETE FROM users WHERE id = ?\', (user_id,))\n    db.commit()\n    return redirect(url_for(\'index\'))\n\n@app.route(\'/query\')\ndef query_users():\n    db = get_db()\n    users = db.execute(\'SELECT * FROM users\').fetchall()\n    return render_template(\'query.html\', users=users)\n\nif __name__ == \'__main__\':\n    init_db()\n    app.run(debug=True)\n \n templates/index.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Index</title>\n</head>\n<body>\n    <h1>Welcome to User Management</h1>\n    <a href="{{ url_for(\'add_user\') }}">Add User</a> |\n    <a href="{{ url_for(\'query_users\') }}">Query Users</a>\n</body>\n</html>\n \n templates/add.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Add User</title>\n</head>\n<body>\n    <h1>Add User</h1>\n    <form action="{{ url_for(\'add_user\') }}" method="post">\n        <label for="student_id">Student ID:</label>\n        <input type="text" id="student_id" name="student_id" required><br>\n        <label for="github_account">GitHub Account:</label>\n        <input type="text" id="github_account" name="github_account" required><br>\n        <label for="notes">Notes:</label>\n        <textarea id="notes" name="notes"></textarea><br>\n        <input type="submit" value="Add">\n    </form>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n templates/update.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Update User</title>\n</head>\n<body>\n    <h1>Update User</h1>\n    <form action="{{ url_for(\'update_user\', user_id=user[\'id\']) }}" method="post">\n        <label for="student_id">Student ID:</label>\n        <input type="text" id="student_id" name="student_id" value="{{ user[\'student_id\'] }}" required><br>\n        <label for="github_account">GitHub Account:</label>\n        <input type="text" id="github_account" name="github_account" value="{{ user[\'github_account\'] }}" required><br>\n        <label for="notes">Notes:</label>\n        <textarea id="notes" name="notes">{{ user[\'notes\'] }}</textarea><br>\n        <input type="submit" value="Update">\n    </form>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n templates/query.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Query Users</title>\n</head>\n<body>\n    <h1>Users</h1>\n    <table>\n        <tr>\n            <th>ID</th>\n            <th>Student ID</th>\n            <th>GitHub Account</th>\n            <th>Notes</th>\n            <th>Actions</th>\n        </tr>\n        {% for user in users %}\n        <tr>\n            <td>{{ user[\'id\'] }}</td>\n            <td>{{ user[\'student_id\'] }}</td>\n            <td>{{ user[\'github_account\'] }}</td>\n            <td>{{ user[\'notes\'] }}</td>\n            <td>\n                <a href="{{ url_for(\'update_user\', user_id=user[\'id\']) }}">Update</a> |\n                <a href="{{ url_for(\'delete_user\', user_id=user[\'id\']) }}">Delete</a>\n            </td>\n        </tr>\n        {% endfor %}\n    </table>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n 3. 啟動應用程式 確保你的 Flask 應用程式和模板文件已經正確配置，然後啟動應用程式： \n python app.py\n \n 接下來, 可以在瀏覽器中訪問  http://127.0.0.1:5000/  來查看和管理你的資料。 \n \n Video: \n https://vimeo.com/user24079973 \n https://www.youtube.com/@-kmolab9376 \n', 'tags': '', 'url': 'References.html'}, {'title': 'Brython', 'text': '從 1 累加到 100: \n 1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Demo', 'text': '\n \n \n  設定 id, 讓 Canvas 繪圖資料可以插入  \n \n \n  以下為 Brython 程式  \n', 'tags': '', 'url': 'Demo.html'}]};